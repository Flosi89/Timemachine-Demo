<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Fr√ºher/Heute Ansicht (GPS + Gesten)</title>
  <style>
    body, html { margin:0; padding:0; height:100%; overflow:hidden; background:#000; font-family: system-ui, sans-serif; }
    #video { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; z-index:0; }
    #overlay {
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
      transform-origin:center center; will-change:transform, opacity; z-index:5; display:none;
    }
    #ui { position:absolute; left:0; right:0; bottom:0; padding:12px; display:grid; gap:10px;
          background:linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.55) 40%, rgba(0,0,0,.75) 100%); z-index:10; }
    input[type=range] { width:100%; }
    #status { position:absolute; top:10px; left:10px; right:10px; color:#fff; background:rgba(0,0,0,.7); padding:8px 10px; border-radius:10px; font-size:14px; z-index:11; white-space:pre-wrap; }
    #reload { position:absolute; top:10px; right:10px; z-index:12; padding:10px 12px; border-radius:10px; border:none; background:#1976d2; color:#fff; font-weight:700; }
  </style>
</head>
<body>
  <div id="status">‚è≥ Lade Orte‚Ä¶</div>
  <button id="reload">Neu pr√ºfen</button>
  <video id="video" autoplay playsinline webkit-playsinline muted></video>
  <img id="overlay" src="">
  <div id="ui">
    <input type="range" min="0" max="100" value="70" id="opacity">
  </div>

  <script>
    const overlay = document.getElementById('overlay');
    const statusBox = document.getElementById('status');
    const reloadBtn = document.getElementById('reload');
    const RADIUS_KM = 0.5;

    function log(msg){ statusBox.textContent += '\n' + msg; }

    // Kamera
    (async function startCam(){
      try{
        const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:{exact:'environment'}},audio:false});
        video.srcObject=s; await video.play().catch(()=>{});
      }catch(e1){
        try{
          const s=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'},audio:false});
          video.srcObject=s; await video.play().catch(()=>{});
        }catch(e2){
          const s=await navigator.mediaDevices.getUserMedia({video:true,audio:false});
          video.srcObject=s; await video.play().catch(()=>{});
        }
      }
    })();

    // Orte
    let ORTE = [];
    async function loadOrte(){
      statusBox.textContent = '‚è≥ Lade Orte‚Ä¶';
      try{
        const r = await fetch('orte.json?v=' + Date.now());
        ORTE = await r.json();
        log('‚úÖ Orte geladen: ' + ORTE.length);
      }catch(err){
        log('‚ùå Orte-Fehler: ' + err.message);
      }
    }

    function distKm(lat1,lng1,lat2,lng2){
      const R=6371;
      const dLat=(lat2-lat1)*Math.PI/180;
      const dLon=(lng2-lng1)*Math.PI/180;
      const a=Math.sin(dLat/2)**2+Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*Math.sin(dLon/2)**2;
      return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }
    function findNearest(lat,lng){
      let best=null, bestDist=Infinity;
      for(const o of ORTE){
        const d=distKm(lat,lng,o.lat,o.lng);
        if(d<bestDist){ bestDist=d; best=o; }
      }
      return {best, distanceKm: bestDist};
    }

    function showImage(src){
      overlay.onload = ()=>{ log('üñºÔ∏è Bild geladen: '+src); overlay.style.display='block'; };
      overlay.onerror = ()=>{ log('‚ùå Bild konnte nicht geladen werden: '+src); };
      overlay.src = src + (src.includes('?')?'&':'?') + 'v=' + Date.now();
    }

    async function checkGPS(){
      if(ORTE.length===0){ await loadOrte(); }
      if(!navigator.geolocation){ log('‚ùå GPS nicht unterst√ºtzt'); return; }
      statusBox.textContent = '‚è≥ Standort wird ermittelt‚Ä¶';
      navigator.geolocation.getCurrentPosition(pos=>{
        const {latitude,longitude}=pos.coords;
        log('üìç ' + latitude.toFixed(5) + ', ' + longitude.toFixed(5));
        const {best, distanceKm} = findNearest(latitude,longitude);
        if(best){
          log('N√§chster Ort: ' + best.name + ' (' + distanceKm.toFixed(2) + ' km)');
          if(distanceKm < RADIUS_KM){
            showImage(best.image);
          } else {
            overlay.style.display='none';
            log('üö´ Kein Ort im Radius ' + RADIUS_KM + ' km');
          }
        } else {
          log('‚ö†Ô∏è Keine Orte in Liste gefunden');
        }
      }, err=>{
        log('‚ùå Standort-Fehler: ' + err.message);
      }, { enableHighAccuracy:true, timeout:10000, maximumAge:0 });
    }

    reloadBtn.addEventListener('click', checkGPS);
    (async ()=>{ await loadOrte(); await checkGPS(); })();

    // Opacity slider
    document.getElementById('opacity').addEventListener('input', e=>{
      overlay.style.opacity = e.target.value/100;
    });

    // --- Gestensteuerung (Pan / Pinch / Rotate) ---
    overlay.style.touchAction = "none"; // wichtig f√ºr Pointer-Events
    let state = { x:0, y:0, scale:1, rot:0 };
    function apply(){ overlay.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale}) rotate(${state.rot}deg)`; }

    // Pointer f√ºr 1-Finger Drag
    let dragging = false, last = {x:0,y:0};
    overlay.addEventListener('pointerdown', e=>{
      if (e.target.closest('#ui')) return; // UI nicht blockieren
      dragging = true; last = {x:e.clientX, y:e.clientY}; overlay.setPointerCapture(e.pointerId);
    });
    overlay.addEventListener('pointermove', e=>{
      if(!dragging) return;
      const dx = e.clientX - last.x; const dy = e.clientY - last.y;
      state.x += dx; state.y += dy; last = {x:e.clientX, y:e.clientY}; apply();
    });
    overlay.addEventListener('pointerup', ()=> dragging=false);
    overlay.addEventListener('pointercancel', ()=> dragging=false);

    // Touch f√ºr 2-Finger Pinch/Rotate
    let twoStart = null;
    function tdist(a,b){ return Math.hypot(a.clientX-b.clientX, a.clientY-b.clientY); }
    function tangle(a,b){ return Math.atan2(b.clientY-a.clientY, b.clientX-a.clientX) * 180/Math.PI; }
    function tcenter(a,b){ return { x:(a.clientX+b.clientX)/2, y:(a.clientY+b.clientY)/2 }; }

    overlay.addEventListener('touchstart', (e)=>{
      if (e.target.closest('#ui')) return;
      if(e.touches.length===2){
        const [t1,t2]=[e.touches[0], e.touches[1]];
        twoStart = { dist: tdist(t1,t2), angle: tangle(t1,t2), center: tcenter(t1,t2),
                     baseScale: state.scale, baseRot: state.rot, baseX: state.x, baseY: state.y };
      }
    }, {passive:false});

    overlay.addEventListener('touchmove', (e)=>{
      if (e.target.closest('#ui')) return;
      if(e.touches.length===2 && twoStart){
        e.preventDefault();
        const [t1,t2]=[e.touches[0], e.touches[1]];
        const scaleFactor = tdist(t1,t2)/Math.max(1,twoStart.dist);
        const rotDelta = tangle(t1,t2) - twoStart.angle;
        state.scale = Math.max(0.2, Math.min(5, twoStart.baseScale * scaleFactor));
        state.rot = twoStart.baseRot + rotDelta;
        const c = tcenter(t1,t2);
        state.x = twoStart.baseX + (c.x - twoStart.center.x);
        state.y = twoStart.baseY + (c.y - twoStart.center.y);
        apply();
      }
    }, {passive:false});

    overlay.addEventListener('touchend', ()=>{ twoStart=null; });
    overlay.addEventListener('touchcancel', ()=>{ twoStart=null; });
  </script>
</body>
</html>
